# ゲームオブジェクト

ゲームワールド内に物理的に存在する多くの要素は、ゲームオブジェクト **game objects**です。現在、これはアイテムのみを対象としていますが、クリーチャーやビークルも間もなく追加され、その後、どこかの時点で備品もおそらく含まれるでしょう。GO は、`game_object.h` name や position のようなメソッドを持つ、小さな共通インターフェースを備えています。
GO はプライベートコンストラクタを使用しています。これは、GO の変数は常に参照またはポインタでなければならないことを意味します。そのような間接レイヤーなしで変数を割り当てようとすると、コンパイルエラーが発生します。同様に、あるオブジェクトを別のオブジェクトにコピーしようとすると、同様のエラーが発生します。

```cpp
item& it_ref = ...; // 適切
item* it_pointer; // 適切

item it = ...; // コンパイルエラー
it_ref = other; // コンパイルエラー
*it_pointer = other; // コンパイルエラー
```

新しい GO は、新しく作成されたゲームオブジェクトへの`detached_ptr` を返す`::spawn` 静的メソッドを介して作成できます。 `detached_ptr`は、現在ゲームワールドに存在しないオブジェクトを表します。

一つのオブジェクトに対して同時に存在できる `detached_ptr` は一つだけです
([`std::unique_ptr`](https://en.cppreference.com/w/cpp/memory/unique_ptr) を知っている方は、この挙動に慣れているでしょう)。

オブジェクトをワールドに追加する関数は、`detached_ptr` を `std::move` で渡すことを要求します。一般に、`detached_ptr` は関数に渡す際に `std::move` されなければなりません。`std::move` された変数をその後使用してはならないことに注意してください。同様に、ワールドからオブジェクトを削除する関数は、`detached_ptr` を返します。これにより、同じものをワールドに二重に追加できないことが保証されます。

ワールドに何も追加しない関数は、通常のポインタを受け取ります。

`detached_ptr` を通常のポインタに変換するには、以下のようにします。これを使用すると、`std::move` の前に行う必要はありますが、 `std::move`した後でも有効なポインタを保持できることに注意してください。

```cpp
&*detached
```

また、以下を使用して逆の操作を行うこともできます。ただし、そのプロセスでオブジェクトがゲームワールドから削除され、ゲームワールドにないオブジェクトに対して呼び出すとエラーが発生することに注意してください。

```cpp
detached_ptr<item> as_detached = normal_ptr->detach();
```

無効な `detached_ptr`（例えば、`std::move` されたもの）にアクセスしようとすると、`debugmsg` が発生し、そのオブジェクトの `null` バージョンが返されます。

## 安全な参照

ゲームオブジェクトは安全な参照をサポートしています。
`safe_reference<item>` は、オブジェクトが破壊された、または現実バブル外にある場合にアクセスを拒否しますが、そのオブジェクトを見失うことはありません。また、セーブおよびロードが可能です。

それが有効であるかどうかを確認するには、ブール値としてチェックする必要があります (例:`if( ref )`) 。有効でないときにアクセスしようとすると、 debugmsgs が発生し、代わりにヌルオブジェクトが返されます。
それらは、破壊されたか、アンロードされたかなどをチェックできる小さなインターフェースを持っています。もし、そのターンに破壊またはアンロードされた場合、オブジェクトに const 形式でアクセスできるメソッドがあり、例えばエラーメッセージを表示するために使用できます。

オブジェクトを移動する場合は `detached_ptr`を使用する必要がありますが、それ以外でどの参照を使用するかを選択する際に最も重要な考慮事項は、どれくらいの期間それを保持したいかです。

- 一時的に使用する場合（例：ほとんどの引数と変数）は、通常の参照またはポインタを使用すべきです。
- より長く保存する必要がある場合は、安全な参照 (safe_reference) を使用すべきであり、これによりセーブファイルに簡単に保存できます。
- 稀なケースとして、ターンをまたいで保存したいが、セーブファイルには保存したくない場合（つまりキャッシュ）、`cache_reference<item>` もあります。これはターンをまたいで持続しますが、保存することはできません。

ゲームオブジェクトは、断片に分割されたり、互いにマージされたりすることがあります。アイテムスタックがその主な例ですが、ビークルの分割や溶解したデバウラーの合体など、他にもあります。

- アイテムスタックが分割されたとき、その場に残るスタックが、安全な参照が追跡する対象です。
- マージされたとき、マージ前のどちらかの半分への安全な参照も、マージ後の結果を指すようになります。
