# 게임 오브젝트

게임 세계에 물리적으로 존재하는 많은 것들이 **게임 오브젝트(GO)**입니다. 현재는 아이템만 해당되지만 곧 크리처와 차량이 추가될 예정이며, 언젠가는 가구도 포함될 것입니다. GO는 `game_object.h`에서 찾을 수 있는 이름 및 위치와 같은 메서드를 가진 작은 공통 인터페이스를 가지고 있습니다. GO는 비공개 생성자를 사용하므로 **변수는 항상 참조 또는 포인터여야 합니다**. 간접 레이어 없이 변수를 할당하려고 하면 컴파일 오류가 발생합니다. 마찬가지로 한 오브젝트를 다른 오브젝트로 복사하려고 하면 유사한 오류가 발생합니다.

```cpp
item& it_ref = ...; // 좋음
item* it_pointer; // 좋음

item it = ...; // 컴파일 오류
it_ref = other; // 컴파일 오류
*it_pointer = other; // 컴파일 오류
```

새 GO는 새로 생성된 게임 오브젝트에 대한 `detached_ptr`을 반환하는 `::spawn` 정적 메서드를 통해 생성할 수 있습니다. `detached_ptr`은 현재 게임 세계에 존재하지 않는 오브젝트를 나타냅니다. 한 번에 하나의 오브젝트에 대한 `detached_ptr`만 있을 수 있습니다([`std::unique_ptr`](https://en.cppreference.com/w/cpp/memory/unique_ptr)을 아는 사람들은 이 동작에 익숙할 것입니다). 오브젝트를 세계에 추가하는 함수는 `detached_ptr`을 `std::move`로 전달해야 합니다. 일반적으로 `detached_ptr`은 함수에 전달될 때 `std::move`되어야 합니다. 이동된 후에는 해당 변수를 사용하면 안 됩니다. 마찬가지로 세계에서 오브젝트를 제거하는 함수는 `detached_ptr`을 반환합니다. 이렇게 하면 같은 것을 세계에 두 번 추가할 수 없습니다.

세계에 추가하지 않는 함수는 일반 포인터를 받습니다. 다음과 같이 `detached_ptr`을 일반 포인터로 변환할 수 있습니다. `std::move` 후에도 유효한 포인터를 유지하려면 `std::move`가 발생하기 전에 이 작업을 수행해야 합니다.

```cpp
&*detached
```

다음과 같이 반대로 갈 수도 있습니다. 단, 이 과정에서 게임 세계에서 오브젝트가 제거되며 게임 세계에 없는 오브젝트에서 호출하면 오류가 발생합니다.

```cpp
detached_ptr<item> as_detached = normal_ptr->detach();
```

유효하지 않은 `detached_ptr`(예: `std::move`된 것)에 액세스하려고 하면 debugmsg가 발생하고 해당 오브젝트의 null 버전이 제공됩니다.

## 안전한 참조

게임 오브젝트는 안전한 참조를 지원합니다. `safe_reference<item>`은 파괴되었거나 현실 버블 밖에 있는 오브젝트에 대한 액세스를 거부하지만 추적은 유지하며, 저장 및 로드할 수 있습니다. 유효한지 확인하려면 불리언으로 확인해야 합니다(예: `if( ref )`). 유효하지 않을 때 액세스하려고 하면 debugmsg가 발생하고 대신 null 오브젝트가 제공됩니다. 파괴되었는지 언로드되었는지 등을 확인할 수 있는 작은 인터페이스가 있습니다. 이번 턴에 파괴되었거나 언로드된 경우, 예를 들어 오류 메시지를 표시하기 위해 const 방식으로 오브젝트에 액세스할 수 있는 메서드가 있습니다.

오브젝트를 이동하려면 `detached_ptr`을 사용해야 하지만, 그렇지 않으면 어떤 참조를 사용할지 선택할 때 가장 중요한 것은 얼마나 오래 보유하고 싶은지입니다. 임시로 사용하는 경우, 예를 들어 대부분의 인수와 변수의 경우 일반 참조 또는 포인터를 사용해야 합니다. 더 오래 저장해야 하는 경우 안전한 참조를 사용해야 하며 이는 저장 파일에 쉽게 저장할 수 있음을 의미합니다. 드물게 턴 간에 저장하고 싶지만 저장 파일에는 저장하고 싶지 않은 경우(즉, 캐시), 턴 간에 지속되지만 저장할 수 없는 빠른 `cache_reference<item>`도 있습니다.

게임 오브젝트는 때때로 조각으로 분할되거나 함께 병합될 수 있습니다. 아이템 스택이 주요 예이지만 차량이 분할되거나 용해된 devourers가 병합되는 것과 같은 다른 예도 있습니다. 아이템 스택이 분할될 때 제자리에 남아 있는 스택이 안전한 참조가 따라가는 스택입니다. 병합될 때 병합의 양쪽 절반에 대한 안전한 참조는 이제 병합 결과를 가리킵니다.
